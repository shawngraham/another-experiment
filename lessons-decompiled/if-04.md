---
id: if-04
title: Generating Worlds: Procedural Story Fragments
moduleId: interactive-fiction
prerequisites:
  - if-03
estimatedTimeMinutes: 35
difficulty: intermediate
learningObjectives:
  - Use random.choice and string formatting to procedurally generate passage text
  - Apply random.seed for reproducible
  - deterministic output
  - Connect procedural generation to Oulipo and combinatorial literature
keywords:
  - procedural generation
  - random.choice
  - random.seed
  - Oulipo
  - Calvino
  - string formatting
---

# Generating Worlds: Procedural Story Fragments

## Analogy

In 1960, the French literary group **Oulipo** (Ouvroir de litterature potentielle — "Workshop of Potential Literature") began exploring literature created through formal constraints and combinatorial methods. Raymond Queneau's *Cent mille milliards de poemes* offered ten sonnets whose lines could be freely recombined, yielding 100 trillion possible poems. Italo Calvino's *The Castle of Crossed Destinies* generated narratives from the combinatorial arrangement of tarot cards. These writers understood that a small set of elements plus a set of rules could produce a vast narrative space. In Python, `random.choice` and string templates give us the same power: define your word banks, define your template, and let the machine explore the space of possibilities.

## Key Concepts

### Word Banks and Templates

Procedural generation starts with two ingredients:
1. **Word banks** — lists of interchangeable elements (settings, objects, adjectives, actions)
2. **A template** — a string with placeholders that the word bank items fill

:::definition
**Procedural generation**: The algorithmic creation of content from rules and component parts, rather than manual authorship of each individual piece.
:::

```python
import random

settings = ["a quiet chapel", "a dusty attic", "a sunlit courtyard"]
objects = ["letter", "painting", "compass"]

template = "You discover a {obj} in {setting}."
result = template.format(
    obj=random.choice(objects),
    setting=random.choice(settings)
)
print(result)
```

Each run produces a different combination — but every result is grammatically valid and narratively plausible.

### Deterministic Output with random.seed

For testing, grading, and reproducibility, we need the "random" choices to be the same every time. The `random.seed()` function fixes the sequence of random numbers:

:::definition
**random.seed**: A function that initializes the random number generator to a fixed state, ensuring that subsequent calls to random functions produce the same sequence of results every time.
:::

```python
import random
random.seed(27)

colors = ["red", "blue", "green", "gold", "silver"]
print(random.choice(colors))  # Always: gold
print(random.choice(colors))  # Always: green
```

With `random.seed(27)\

---challenges---
